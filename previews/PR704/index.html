<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DiffEqFlux.jl: Generalized Physics-Informed and Scientific Machine Learning (SciML) · DiffEqFlux.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://diffeqflux.sciml.ai/stable/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="DiffEqFlux.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>DiffEqFlux.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DiffEqFlux.jl: Generalized Physics-Informed and Scientific Machine Learning (SciML)</a><ul class="internal"><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#Applications"><span>Applications</span></a></li><li><a class="tocitem" href="#Modularity-and-Composability"><span>Modularity and Composability</span></a></li><li><a class="tocitem" href="#Citation"><span>Citation</span></a></li></ul></li><li><span class="tocitem">Ordinary Differential Equation (ODE) Tutorials</span><ul><li><a class="tocitem" href="examples/optimization_ode/">Optimization of Ordinary Differential Equations</a></li><li><a class="tocitem" href="examples/stiff_ode_fit/">Parameter Estimation on Highly Stiff Systems</a></li><li><a class="tocitem" href="examples/neural_ode_sciml/">Neural Ordinary Differential Equations with sciml_train</a></li><li><a class="tocitem" href="examples/mnist_neural_ode/">GPU-based MNIST Neural ODE Classifier</a></li><li><a class="tocitem" href="examples/mnist_conv_neural_ode/">Convolutional Neural ODE MNIST Classifier on GPU</a></li><li><a class="tocitem" href="examples/augmented_neural_ode/">Augmented Neural Ordinary Differential Equations</a></li><li><a class="tocitem" href="examples/collocation/">Smoothed Collocation for Fast Two-Stage Training</a></li><li><a class="tocitem" href="examples/neural_gde/">Neural Graph Differential Equations</a></li><li><a class="tocitem" href="examples/exogenous_input/">Handling Exogenous Input Signals</a></li><li><a class="tocitem" href="examples/normalizing_flows/">Continuous Normalizing Flows with GalacticOptim.jl</a></li></ul></li><li><span class="tocitem">Direct Usage with Optimizer Backends</span><ul><li><a class="tocitem" href="examples/neural_ode_galacticoptim/">Neural Ordinary Differential Equations with GalacticOptim.jl</a></li><li><a class="tocitem" href="examples/neural_ode_flux/">Neural Ordinary Differential Equations with Flux.train!</a></li></ul></li><li><span class="tocitem">Training Techniques</span><ul><li><a class="tocitem" href="examples/multiple_shooting/">Multiple Shooting</a></li><li><a class="tocitem" href="examples/local_minima/">Strategies to Avoid Local Minima</a></li><li><a class="tocitem" href="examples/prediction_error_method/">Prediction error method (PEM)</a></li><li><a class="tocitem" href="examples/divergence/">Handling Divergent and Unstable Trajectories</a></li><li><a class="tocitem" href="examples/multiple_nn/">Simultaneous Fitting of Multiple Neural Networks</a></li><li><a class="tocitem" href="examples/data_parallel/">Data-Parallel Multithreaded, Distributed, and Multi-GPU Batching</a></li><li><a class="tocitem" href="examples/second_order_neural/">Neural Second Order Ordinary Differential Equation</a></li><li><a class="tocitem" href="examples/second_order_adjoints/">Newton and Hessian-Free Newton-Krylov with Second Order Adjoint Sensitivity Analysis</a></li><li><a class="tocitem" href="examples/minibatch/">Training a Neural Ordinary Differential Equation with Mini-Batching</a></li></ul></li><li><span class="tocitem">Stochastic Differential Equation (SDE) Tutorials</span><ul><li><a class="tocitem" href="examples/optimization_sde/">Optimization of Stochastic Differential Equations</a></li><li><a class="tocitem" href="examples/neural_sde/">Neural Stochastic Differential Equations</a></li></ul></li><li><span class="tocitem">Delay Differential Equation (DDE) Tutorials</span><ul><li><a class="tocitem" href="examples/delay_diffeq/">Delay Differential Equations</a></li></ul></li><li><span class="tocitem">Differential-Algebraic Equation (DAE) Tutorials</span><ul><li><a class="tocitem" href="examples/physical_constraints/">Enforcing Physical Constraints via Universal Differential-Algebraic Equations</a></li></ul></li><li><span class="tocitem">Partial Differential Equation (PDE) Tutorials</span><ul><li><a class="tocitem" href="examples/pde_constrained/">Partial Differential Equation (PDE) Constrained Optimization</a></li></ul></li><li><span class="tocitem">Hybrid and Jump Equation Tutorials</span><ul><li><a class="tocitem" href="examples/hybrid_diffeq/">Training Neural Networks in Hybrid Differential Equations</a></li><li><a class="tocitem" href="examples/bouncing_ball/">Bouncing Ball Hybrid ODE Optimization</a></li><li><a class="tocitem" href="examples/jump/">Neural Jump Diffusions (Neural Jump SDE) and Neural Partial Differential Equations (Neural PDEs)</a></li></ul></li><li><span class="tocitem">Bayesian Estimation Tutorials</span><ul><li><a class="tocitem" href="examples/turing_bayesian/">Bayesian Estimation of Differential Equations with Probabilistic Programming</a></li><li><a class="tocitem" href="examples/BayesianNODE_NUTS/">Bayesian Neural ODEs: NUTS</a></li><li><a class="tocitem" href="examples/BayesianNODE_SGLD/">Bayesian Neural ODEs: SGLD</a></li></ul></li><li><span class="tocitem">Optimal and Model Predictive Control Tutorials</span><ul><li><a class="tocitem" href="examples/optimal_control/">Solving Optimal Control Problems with Universal Differential Equations</a></li><li><a class="tocitem" href="examples/feedback_control/">Universal Differential Equations for Neural Feedback Control</a></li><li><a class="tocitem" href="examples/SDE_control/">Controlling Stochastic Differential Equations</a></li></ul></li><li><span class="tocitem">Universal Differential Equations and Physical Layer Tutorials</span><ul><li><a class="tocitem" href="examples/universal_diffeq/">Universal Ordinary, Stochastic, and Partial Differential Equation Examples</a></li><li><a class="tocitem" href="examples/tensor_layer/">Physics Informed Machine Learning with TensorLayer</a></li><li><a class="tocitem" href="examples/hamiltonian_nn/">Hamiltonian Neural Network</a></li></ul></li><li><span class="tocitem">Layer APIs</span><ul><li><a class="tocitem" href="layers/BasisLayers/">Classical Basis Layers</a></li><li><a class="tocitem" href="layers/TensorLayer/">Tensor Product Layer</a></li><li><a class="tocitem" href="layers/CNFLayer/">Continuous Normalizing Flows Layer</a></li><li><a class="tocitem" href="layers/SplineLayer/">Spline Layer</a></li><li><a class="tocitem" href="layers/NeuralDELayers/">Neural Differential Equation Layers</a></li><li><a class="tocitem" href="layers/HamiltonianNN/">Hamiltonian Neural Network Layer</a></li></ul></li><li><span class="tocitem">Manual and APIs</span><ul><li><a class="tocitem" href="ControllingAdjoints/">Controlling Choices of Adjoints</a></li><li><a class="tocitem" href="Flux/">Use with Flux Chain and train!</a></li><li><a class="tocitem" href="FastChain/">FastChain</a></li><li><a class="tocitem" href="Collocation/">Smoothed Collocation</a></li><li><a class="tocitem" href="GPUs/">GPUs</a></li><li><a class="tocitem" href="sciml_train/">sciml_train and GalacticOptim.jl</a></li></ul></li><li><a class="tocitem" href="Benchmark/">Benchmarks</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DiffEqFlux.jl: Generalized Physics-Informed and Scientific Machine Learning (SciML)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DiffEqFlux.jl: Generalized Physics-Informed and Scientific Machine Learning (SciML)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqFlux.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DiffEqFlux:-Generalized-Physics-Informed-and-Scientific-Machine-Learning-(SciML)"><a class="docs-heading-anchor" href="#DiffEqFlux:-Generalized-Physics-Informed-and-Scientific-Machine-Learning-(SciML)">DiffEqFlux: Generalized Physics-Informed and Scientific Machine Learning (SciML)</a><a id="DiffEqFlux:-Generalized-Physics-Informed-and-Scientific-Machine-Learning-(SciML)-1"></a><a class="docs-heading-anchor-permalink" href="#DiffEqFlux:-Generalized-Physics-Informed-and-Scientific-Machine-Learning-(SciML)" title="Permalink"></a></h1><p>DiffEqFlux.jl is a parameter estimation system for the SciML ecosystem. It is a high level interface that pulls together all of the tools with heuristics and helper functions to make solving inverse problems and inferring models as easy as possible without losing efficiency.</p><p>DiffEqFlux.jl is for universal differential equations, where these can include delays, physical constraints, stochasticity, events, and all other kinds of interesting behavior that shows up in scientific simulations. Neural networks can be all or part of the model. They can be around the differential equation, in the cost function, or inside of the differential equation. Neural networks representing unknown portions of the model or functions can go anywhere you have uncertainty in the form of the scientific simulator. Forward sensitivity and adjoint equations are automatically generated with checkpointing and stabilization to ensure it works for large stiff equations, while specializations on static objects allows for high efficiency on small equations. For an overview of the topic with applications, consult the paper <a href="https://arxiv.org/abs/2001.04385">Universal Differential Equations for Scientific Machine Learning</a>.</p><p>You can efficiently use the package for:</p><ul><li>Parameter estimation of scientific models (ODEs, SDEs, DDEs, DAEs, etc.)</li><li>Neural ODEs, Neural SDE, etc.</li><li>Nonlinear optimal control, including training neural controllers</li><li>(Stiff) universal ordinary differential equations (universal ODEs)</li><li>Universal stochastic differential equations (universal SDEs)</li><li>Universal delay differential equations (universal DDEs)</li><li>Universal partial differential equations (universal PDEs)</li><li>Universal jump stochastic differential equations (universal jump diffusions)</li><li>Hybrid universal differential equations (universal DEs with event handling)</li></ul><p>with high order, adaptive, implicit, GPU-accelerated, Newton-Krylov, etc. methods. For examples, please refer to <a href="https://julialang.org/blog/2019/01/fluxdiffeq">the release blog post</a> (which we try to keep updated for changes to the libraries). Additional demonstrations, like neural PDEs and neural jump SDEs, can be found <a href="http://www.stochasticlifestyle.com/neural-jump-sdes-jump-diffusions-and-neural-pdes/">at this blog post</a> (among many others!). All of these features are only part of the advantage, as this library <a href="Benchmark/#Benchmarks">routinely benchmarks orders of magnitude faster than competing libraries like torchdiffeq</a>. Use with GPUs is highly optimized by <a href="https://www.stochasticlifestyle.com/solving-systems-stochastic-pdes-using-gpus-julia/">recompiling the solvers to GPUs to remove all CPU-GPU data transfers</a>, while use with CPUs uses specialized kernels for accelerating differential equation solves.</p><p>Many different training techniques are supported by this package, including:</p><ul><li>Optimize-then-discretize (backsolve adjoints, checkpointed adjoints, quadrature adjoints)</li><li>Discretize-then-optimize (forward and reverse mode discrete sensitivity analysis)<ul><li>This is a generalization of <a href="https://arxiv.org/pdf/1902.10298.pdf">ANODE</a> and <a href="https://arxiv.org/pdf/1906.04596.pdf">ANODEv2</a> to all <a href="https://diffeq.sciml.ai/latest/solvers/ode_solve/">DifferentialEquations.jl ODE solvers</a></li></ul></li><li>Hybrid approaches (adaptive time stepping + AD for adaptive discretize-then-optimize)</li><li>Collocation approaches (two-stage methods, multiple shooting, etc.)</li><li>O(1) memory backprop of ODEs via BacksolveAdjoint, and Virtual Brownian Trees for O(1) backprop of SDEs</li><li><a href="https://diffeq.sciml.ai/stable/analysis/sensitivity/#Example-continuous-adjoints-on-an-energy-functional">Continuous adjoints for integral loss functions</a></li><li>Probabilistic programming and variational inference on ODEs/SDEs/DAEs/DDEs/hybrid equations etc. is provided by integration with <a href="https://turing.ml/dev/">Turing.jl</a> and <a href="https://github.com/probcomp/Gen.jl">Gen.jl</a>. Reproduce <a href="https://arxiv.org/abs/2001.01328">variational loss functions</a> by plugging <a href="https://turing.ml/dev/tutorials/9-variationalinference/">composible libraries together</a>.</li></ul><p>all while mixing forward mode and reverse mode approaches as appropriate for the most speed. For more details on the adjoint sensitivity analysis methods for computing fast gradients, see the <a href="ControllingAdjoints/#adjoints">Adjoints page</a>.</p><p>With this package, you can explore various ways to integrate the two methodologies:</p><ul><li>Neural networks can be defined where the “activations” are nonlinear functions described by differential equations</li><li>Neural networks can be defined where some layers are ODE solves</li><li>ODEs can be defined where some terms are neural networks</li><li>Cost functions on ODEs can define neural networks</li></ul><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><p>The basics are all provided by the <a href="https://diffeq.sciml.ai/latest/">DifferentialEquations.jl</a> package. Specifically, <a href="https://diffeq.sciml.ai/latest/analysis/sensitivity/">the <code>solve</code> function is automatically compatible with AD systems like Zygote.jl</a> and thus there is no machinery that is necessary to use DifferentialEquations.jl package. For example, the following computes the solution to an ODE and computes the gradient of a loss function (the sum of the ODE&#39;s output at each timepoint with dt=0.1) via the adjoint method:</p><pre><code class="language-julia hljs">using DiffEqSensitivity, OrdinaryDiffEq, Zygote

function fiip(du,u,p,t)
  du[1] = dx = p[1]*u[1] - p[2]*u[1]*u[2]
  du[2] = dy = -p[3]*u[2] + p[4]*u[1]*u[2]
end
p = [1.5,1.0,3.0,1.0]; u0 = [1.0;1.0]
prob = ODEProblem(fiip,u0,(0.0,10.0),p)
sol = solve(prob,Tsit5())
loss(u0,p) = sum(solve(prob,Tsit5(),u0=u0,p=p,saveat=0.1))
du01,dp1 = Zygote.gradient(loss,u0,p)</code></pre><p>Thus, what DiffEqFlux.jl provides is:</p><ul><li>A bunch of tutorials, documentation, and test cases for this combination with neural network libraries and GPUs</li><li>Pre-built layer functions for common use cases, like neural ODEs</li><li>Specialized layer functions (<code>FastDense</code>) to improve neural differential equation training performance</li><li>Compatibility with a multifunctional optimization package <a href="https://github.com/SciML/GalacticOptim.jl">GalacticOptim.jl</a> with a training loop that allows non-machine learning libraries to be easily utilized</li></ul><h2 id="Applications"><a class="docs-heading-anchor" href="#Applications">Applications</a><a id="Applications-1"></a><a class="docs-heading-anchor-permalink" href="#Applications" title="Permalink"></a></h2><p>The approach of this package is the efficient training of <a href="https://arxiv.org/abs/2001.04385">Universal Differential Equations</a>. Since this is a fairly general class of problems, the following applications are readily available as specific instances of this methodology, and are showcased in tutorials and layer functions:</p><ul><li>Neural ODEs</li><li>Neural SDEs</li><li>Neural DAEs</li><li>Neural DDEs</li><li>Augmented Neural ODEs</li><li>Graph Neural ODEs</li><li>Hamiltonian Neural Networks (with specialized second order and symplectic integrators)</li><li>Lagrangian Neural Networks</li><li>Continuous Normalizing Flows (CNF) and FFJORD</li><li>Galerkin Neural ODEs</li></ul><h2 id="Modularity-and-Composability"><a class="docs-heading-anchor" href="#Modularity-and-Composability">Modularity and Composability</a><a id="Modularity-and-Composability-1"></a><a class="docs-heading-anchor-permalink" href="#Modularity-and-Composability" title="Permalink"></a></h2><p>Note that DiffEqFlux.jl purely built on composable and modular infrastructure. In fact, DiffEqFlux.jl&#39;s functions are not even directly required for performing many of these operations! DiffEqFlux provides high level helper functions and documentation for the user, but the code generation stack is modular and composes in many different ways. For example, one can use and swap out the ODE solver between any common interface compatible library, like:</p><ul><li>Sundials.jl</li><li>OrdinaryDiffEq.jl</li><li>LSODA.jl</li><li><a href="https://github.com/mikelehu/IRKGaussLegendre.jl">IRKGaussLegendre.jl</a></li><li><a href="https://github.com/SciML/SciPyDiffEq.jl">SciPyDiffEq.jl</a></li><li><a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/">... etc. many other choices!</a></li></ul><p>In addition, due to the composability of the system, none of the components are directly tied to the Flux.jl machine learning framework. For example, you can <a href="https://youtu.be/n2MwJ1guGVQ?t=284">use DiffEqFlux.jl to generate TensorFlow graphs and train the neural network with TensorFlow.jl</a>, <a href="https://github.com/FluxML/Torch.jl">utilize PyTorch arrays via Torch.jl</a>, and more all with single line code changes by utilizing the underlying code generation. The tutorials shown here are thus mostly a guide on how to use the ecosystem as a whole, only showing a small snippet of the possible ways to compose the thousands of differentiable libraries together! Swap out ODEs for SDEs, DDEs, DAEs, etc., put quadrature libraries or <a href="https://github.com/mcabbott/Tullio.jl">Tullio.jl</a> in the loss function, the world is your oyster!</p><p>As a proof of composability, note that the implementation of Bayesian neural ODEs required zero code changes to the library, and instead just relied on the composability with other Julia packages.</p><h2 id="Citation"><a class="docs-heading-anchor" href="#Citation">Citation</a><a id="Citation-1"></a><a class="docs-heading-anchor-permalink" href="#Citation" title="Permalink"></a></h2><p>If you use DiffEqFlux.jl or are influenced by its ideas, please cite:</p><pre><code class="nohighlight hljs">@article{rackauckas2020universal,
  title={Universal differential equations for scientific machine learning},
  author={Rackauckas, Christopher and Ma, Yingbo and Martensen, Julius and Warner, Collin and Zubov, Kirill and Supekar, Rohit and Skinner, Dominic and Ramadhan, Ali},
  journal={arXiv preprint arXiv:2001.04385},
  year={2020}
}</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/optimization_ode/">Optimization of Ordinary Differential Equations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Sunday 1 May 2022 23:16">Sunday 1 May 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
